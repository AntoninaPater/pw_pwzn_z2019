---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

<!-- #region {"slideshow": {"slide_type": "slide"}} -->
# Python w zastosowaniach naukowych
                
## Wykład 5
### mgr inż. Maciej Kwiatkowski
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "slide"}} -->
# Klasy c.d.
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "slide"}} -->
# OOP *(Object Oriented Programming)*
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
Programowanie obiektowe charakteryzują cztery cechy:
* abstrakcja 
* polimorfizm
* hermetyzacja
* dziedziczenie

<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "slide"}} -->
# Hermetyzacja
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
Hermetyzacja (inaczej zwana kapsułkowaniem, ang. *encapsulation*) w programowaniu obiektowym polega na ukryciu części atrybutów/metod klasy tzn. zmianę ich wartości lub wywołanie mogą zrobić tylko inne metody klasy. 

Takie podejście pozwala lepiej realizować cechę abstrakcji (oddzielenia implementacji od użycia) jak również pozwala na “uodpornienie” kodu przed niepożądaną zmianą wartości atrybutów i w efekcie błędnym działaniem klasy.
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
Atrybuty i metody niedostępne z “zewnątrz” nazywamy **prywatnymi**.

Zbiór metod i wartości dostępnych publicznie nazywamy **interfejsem**.
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "subslide"}} -->
# Prywatność
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
W Pythonie prywatność zmiennych jest kwestią raczej umowną. 

Oznacza to, że wszystkie atrybuty i metody są domyślnie dostępne, a zablokowanie ich zmienności wiąże się z dodatkowym nakładem pracy (dodatkowym kodem). 

Korzyścią wynikającą z takiego podejścia jest łatwa analiza kodu i przejrzystość klas, minusem łatwa możliwość “uszkodzenia” klasy.
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "subslide"}} -->
# Konwencja nazw zmiennych
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
* `snake_case` - zmienne globalne, parametry funkcji, nazwy paczek i modułów, atrybuty i metody klasy,
* `UpperCamelCase` - klasy, nazwy typów,
* `UPPER_SNAKE_CASE` - zmienne-"stałe" - ich wartości nie powinniśmy zmieniać,
* `dotted.notation` - dostęp do atrybutów obiektu.
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "subslide"}} -->
# Konwencja nazw zmiennych
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
* `<nazwa_atrybutu>` - określa zmienną publiczną,
* `_<nazwa_atrybutu>` - określa zmienną chronioną, tzn. zmienną, której nie powinno sie edytować z zewnątrz klasy, 
* `__<nazwa_atrybutu>` - określa zmienną prywatną, zmienną, której nazwa jest ukrywana przez interpreter,
* `__<nazwa_atrybutu>__` - określa zmienną magiczna, która nie jest ukrywana przez interpreter.

Analogiczna konwencja obowiązuje dla metod.
<!-- #endregion -->

```{python slideshow={'slide_type': 'subslide'}}
class A:
    _access_count = 0
    
    def __init__(self, a):
        self.a = a
        self._access_count += 1
        self.__b = a * 456
    
    @property
    def access_count(self):
        return self._access_count
```

```{python slideshow={'slide_type': 'fragment'}}
var_1 = A(4)
print(f'public attribute var_1.a={var_1.a}')
print(f'protected attribute var_1._access_count={var_1._access_count}')
print(f'protected attribute accessed via interface var_1.access_count={var_1.access_count}')
print(f'private attribute var_1._A__b={var_1._A__b}')
```

```{python slideshow={'slide_type': 'fragment'}}
# Atrybut prywatny nie może być wywołany z zewnątrz
print(f'private attribute var_1.__b={var_1.__b}')
```

```{bash slideshow={'slide_type': 'subslide'}}
touch priv_example.py
echo "a_priv_example = 1
_b_priv_example = 2
__c_priv_example = 3" > priv_example.py
```

```{python slideshow={'slide_type': 'fragment'}}
from priv_example import *
print(a_priv_example)
print(_b_priv_example)
```

```{python slideshow={'slide_type': 'fragment'}}
print(__c_priv_example)
```

```{bash slideshow={'slide_type': 'subslide'}}
touch priv_example_2.py

echo "__all__ = ('a_priv_example_2',)

a_priv_example_2 = 1
b_priv_example_2 = 2
c_priv_example_2 = 3" > priv_example_2.py
```

```{python}
from priv_example_2 import *
print(a_priv_example_2)
print(b_priv_example_2)
```

```{python slideshow={'slide_type': 'fragment'}}
print(__c_priv_example_2)
```

<!-- #region {"slideshow": {"slide_type": "subslide"}} -->
# Getter i setter
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
Poza konwencją nazw prywatność realizowana jest za pomocą **gettera** i **settera**. Są to dwie funkcje kontrolujące odczytwanie i zapisywanie do zmiennej.

Wspomniana na poprzednich zajęciach *własność* (`property`) to właśnie taki getter. Ponieważ nie zdefiniowaliśmy settera możliwe było stworzenie *nieedytowalnej publicznej zmiennej*. 
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
W celu dodania settera musimy skorzystać z dekoratora `<nazwa_własności>.setter`.
<!-- #endregion -->

```{python slideshow={'slide_type': 'subslide'}}
from numbers import Number


class Point:
    __x = None
    
    def __init__(self, x): 
        self.x = x

    @property
    def x(self):
        return self.__x

    @x.setter
    def x(self, x):
        if not isinstance(x, Number):
            print("Not number value!")
        else: self.__x = x
```

```{python slideshow={'slide_type': 'fragment'}}
p1 = Point(1.)
print('P1 x: ', p1.x)
p1.x = 2.
print('P1 x: ', p1.x)
p1.x = 'a'
print('P1 x: ', p1.x)
```

<!-- #region {"slideshow": {"slide_type": "subslide"}} -->
Możliwe jest zdefiniowanie gettera i settera atrybutu używając innych, już istniejących w klasie metod. 

Realizuje się to przez wywołanie dekoratora `property` jako funkcji.
<!-- #endregion -->

```{python slideshow={'slide_type': 'fragment'}}
class Point:
    def __init__(self, x): self.x = x
    def get_x(self): return self.__x

    def set_x(self, x):
        if not isinstance(x, Number):
            print("Not number value!")
        else: self.__x = x

    x = property(get_x, set_x)
```

```{python slideshow={'slide_type': 'subslide'}}
class Point:
    def __init__(self, x): self.x = x
    def get_x(self): return self.__x

    def set_x(self, x):
        if not isinstance(x, Number):
            print("Not number value!")
        else: self.__x = x

    x = property(get_x, set_x)
```

```{python slideshow={'slide_type': 'fragment'}}
p1 = Point(1.)
print('P1 x: ', p1.get_x())
p1.set_x(2.)
print('P1 x: ', p1.get_x())
p1.set_x('a')
print('P1 x: ', p1.get_x())
```

```{python slideshow={'slide_type': 'fragment'}}
p2 = Point(1.)
print('P2 x: ', p2.x)
p2.x = 2.
p2.x = 'a'
print('P2 x: ', p2.x)
```

```{python slideshow={'slide_type': 'subslide'}}
class Dog:
    def __init__(self):
        self._belly = None
        
    def eat_sth(self, sth):
        self._belly = sth
        
    mouth = property(None, eat_sth)
    
dog = Dog()
dog.mouth = 4
print(dog.mouth)
```

<!-- #region {"slideshow": {"slide_type": "slide"}} -->
# Dziedziczenie
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
Dziedziczenie to mechanizm współdzielenia funkcjonalności między klasami. Klasa, która dziedziczy po innej klasie poza własnymi atrybutami i metodami “dziedziczy” atrybuty i metody klasy “rodzica” (posiada do nich dostęp w swojej definicji).

Klasa, która dziedziczy nazywa się **podklasą** (eng. *subclass*) lub *klasą-dzieckiem*. 

Klasa, po której się dziedziczy nazywana jest **klasą bazową** (eng. *superclass*) lub klasą-rodzicem.
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
**Klasy, po których się dziedziczy, określa się poprzez podanie ich w nagłówku klasy**, po nazwie klasy (w nawiasie, w podobny sposób jak parametry funkcji).
<!-- #endregion -->

```{python slideshow={'slide_type': 'fragment'}}
class KlasaA(object):  # równoważne do class KlasaA:
    pass
```

<!-- #region {"slideshow": {"slide_type": "subslide"}} -->
# Dziedziczenie - ograniczenia 
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
* **Każda klasa może być rodzicem dla wielu innych klas potomnych** niezależnie tzn. to że klasa A jest rodzicem klasy B i C nie powoduje, że klasy B i C “widzą” siebie nawzajem. 
* Podobnie klasa może dziedziczyć po wielu różnych klasach.
* **Dziedziczenie jest relacją przechodnią “w dół”** (oznacza to, że każda instancja dziecko jest typu klasy dziecko i typu klasy rodzica), ale nie “w górę” (instancja klasy rodzica nie jest typu klasy dziecka). 
* Dziedziczenie po jakiejś klasie nie wyklucza klasy z możliwości bycia “rodzicem” dla innej klasy.
<!-- #endregion -->

```{python slideshow={'slide_type': 'subslide'}}
class A(object):
    a = 1

class B(A):
    b = 2
```

```{python slideshow={'slide_type': 'fragment'}}
# Tworzenie instancji obu klas
a = A()
b = B()

print('Czy klasa B jest podklasą klasy A?: ', issubclass(B, A))
print('Czy klasa A jest podklasą klasy object?: ', issubclass(A, object))
print('Czy klasa B jest podklasą klasy object?: ', issubclass(B, object))
#instancje
print('*'*15)
print('Czy instancja klasy B jest typu B?: ', isinstance(b, B))
print('Czy instancja klasy B jest typu A?: ', isinstance(b, A))
print('Czy instancja klasy A jest typu B?: ', isinstance(a, B))
print('Czy instancja klasy A jest typu object?: ', isinstance(a, object))
print('Czy instancja klasy B jest typu object?: ', isinstance(b, object))
```

```{python slideshow={'slide_type': 'subslide'}}
class A(object):
    a = 1


class B(A):
    b = 2
    
    
class C(A):
    b = 4

    def __init__(self):
        self.a = C.a + 5
```

```{python slideshow={'slide_type': 'fragment'}}
# Tworzenie instancji obu klas
a = A()
b = B()
c = C()

A.a = 5  # nadpisanie atrybutu instancji!!
print('a.a', a.a)
print('b.a', b.a)
print('b.b', b.b)
print('c.a', c.a)
print('c.b', c.b)
```

<!-- #region {"slideshow": {"slide_type": "subslide"}} -->
#  Klasa: dziedzictwo
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
* **Klasa dziedzicząca może nadpisywać odziedziczone metody** poprzez zdefiniowanie wewnątrz siebie metody o takiej samej nazwie jak metoda rodzica. **Nie powoduje to jednak nadpisania definicji tej metody w klasie rodzica.**
* W przypadku wywołania metody instancji klasy dziecka wywołana zostanie nowo zdefiniowana metoda.
* Klasa dziecko może odwołać się metody rodzica za pomocą funkcji: `super().<nazwa_metody>`.
<!-- #endregion -->

```{python slideshow={'slide_type': 'subslide'}}
class A(object):
    def __init__(self, b=None):
        if b is not None:
            self.b = b
    a = 1


class B(A):
    b = 2

# Klasa C dziedziczy po klasie A, niezależnie od klasy B
class C(A):

    # Klasa C rozszerza swoją definicję względem klasy A o metodę describe
    def describe(self):
        print(f'C.b =', self.b)
        print(f'{self.__class__.__name__}.b =', self.b)

class D(C):
    # Klasa D zmienia definicję metody describe
    def describe(self):
        print(f'D: a = {self.a}, b = {self.b}')

class E(C):
    def describe(self):
        super().describe()
        print('E.b =', self.b)

class F(E):
    pass
```

```{python slideshow={'slide_type': 'subslide'}}
a = A(5)
b1 = B()
b2 = B(3)
c = C(7)
d = D('lalala')
e = E([1,2,3])

print('A.b: ', a.b)
print('B1.b: ', b1.b)
print('B2.b: ', b2.b)
print('Metoda describe klasy C:')
c.describe()
print('Metoda describe klasy D:')
d.describe()
print('Metoda describe klasy E:')
e.describe()
print('Metoda describe klasy F:')
f = F('/')
f.describe()
```

```{python slideshow={'slide_type': 'subslide'}}
class Kosa:
    def maintain(self):
        print('Ostrzę kosę')

    def cut(self):
        print('Tnę zboże')


class Cep:
    def maintain(self):
        print('Sprawdzam supły')

    def hit(self):
        print('Młócę zboże')


class Kombajn(Cep, Kosa):
    def maintain(self):
        Kosa.maintain(self)
        Cep.maintain(self)

    def do(self):
        super().cut()
        super().hit()


k = Kombajn()
print('konserwacja:')
k.maintain()
print('-' * 15)
print('użycie:')
k.do()

```

<!-- #region {"slideshow": {"slide_type": "subslide"}} -->
# Dziedziczenie diamentowe
<!-- #endregion -->

```{python slideshow={'slide_type': 'fragment'}}
class A:
    def __init__(self):
        super().__init__()
        print('Class A')

class B(A):
    def __init__(self):
        super().__init__()
        print('Class B')

class C(A):
    def __init__(self):
        super().__init__()
        print('Class C')

class D(B,C):
# class D(C,B):
    def __init__(self):
        super().__init__()
        print('Class D')
```

```{python slideshow={'slide_type': 'subslide'}}
a = A()
print(15 * '-')
b = B()
print(15 * '-')
c = C()
print(15 * '-')
d = D()
```

<!-- #region {"slideshow": {"slide_type": "subslide"}} -->
* Mechanizm rozwiązywania zależności w dziedziczeniu w Pythonie nazywa się **MRO (Method Resolution Order)**.
* Informację o wynikach działania MRO (kolejności dziedziczenia) można zobaczyć wywołując `help(<nazwa klasy>)`.
* **Metoda** `super` może nie być tak super, **gdyż jej wywołanie jest zależne od instancji wywołującej metodę** i przez to metoda może zachowywać się w sposób nieoczekiwany przy złożonym dziedziczeniu!
<!-- #endregion -->

```{python slideshow={'slide_type': 'subslide'}}
help(D)
```

```{python slideshow={'slide_type': 'subslide'}}
class A:
    counter = 0
    def __init__(self):
        print('Class A')
        self.increase()

    def increase(self, val=1):
        self.counter += val
        print(self.counter)


class B(A):
    def __init__(self):
        super().__init__()
        print('Class B')
        self.increase()


class C(A):
    def __init__(self):
        super().__init__()
        print('Class C')
        self.increase(4)


class D(C,B):
    def __init__(self):
        super().__init__()
        print('Class D')
        self.increase(-1)
```

```{python slideshow={'slide_type': 'subslide'}}
a = A()
print(15 * '-')
b = B()
print(15 * '-')
c = C()
print(15 * '-')
d = D()
```

```{python slideshow={'slide_type': 'subslide'}}
class Machine:
    def __init__(self, name, *args, **kwargs):
        self.name = name

    def scan(self):
        print(f"Machine {self.name} do not scan.")

    def print(self):
        print(f"Machine: {self.name}.")


class Printer(Machine):
    def __init__(self, name, is_color, *args, **kwargs):
#         Machine.__init__(self, name)
        super().__init__(name)
        self.is_color = is_color

    def print(self):
        print(
            f"Printer {self.name} print test page"
            f"{' in color' if self.is_color else ''}."
        )


class Scanner(Machine):
    def __init__(self, name, dpi=200, *args, **kwargs):
        super().__init__(name, *args, **kwargs)
        self._dpi = dpi

    def scan(self):
        print(f"Scanner {self.name} scan in dpi {self._dpi}.")
        
    @property
    def dpi(self):
        return self._dpi
```

```{python slideshow={'slide_type': 'subslide'}}
class Xero(Printer, Scanner):
    def __init__(self, name, is_color):
        super().__init__(name, is_color=is_color)
        
machine = Machine("Amiga")
machine.scan()
machine.print()
print(15 * '-')
printer = Printer("Lexmark", True)
printer.scan()
printer.print()
print(15 * '-')
scanner = Scanner("Hp", 400)
scanner.scan()
scanner.print()
print(15 * '-')
xero = Xero("Xerox", True)
xero.scan()
xero.print()
```

```{python slideshow={'slide_type': 'subslide'}}
help(Xero)
```

<!-- #region {"slideshow": {"slide_type": "slide"}} -->
# Wyjątki i błędy
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
* **Błędy składni** (eng. *Syntax Error*) są to błędy wynikające z kodu, którego nie da się skompilować (np. linijka która powinna się kończyć dwukropkiem go nie posiada), wykrywane przed uruchomieniem interpretera,
* **Wyjątki** (eng. *Exceptions*), czyli błędy w logice kodu. Kod prowadzący do podniesienia wyjątku jest poprawny na poziomie składni, ale prowadzi do błędnego/niemożliwego do zrealizowania polecenia (np. odwołania się do zmiennej przed jej zdefiniowaniem).
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
Python ułatwia analizę kodu poprzez podanie ścieżki do wyjątku (eng. *Traceback*) zawierającej wszystkie konteksty (i linijki kodu) od lokalnego (zawierającego błąd) do globalnego (uruchomionego pliku).
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "subslide"}} -->
# Przechwytywanie wyjątków
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
Spodziewając się, że fragment kodu może powodować błędne działanie (zwłaszcza ten operujący na danych od użytkownika) możliwe jest przechwycenie i obsłużenie potencjalnego wyjątku. Podejście to jest *more Pythonic*, zwłaszcza gdy nasz kod okazuje się nie do końca być kaczką ;)
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
Składnia przechwytująca wyjątki to `try-except` (nie `try-catch`!).
<!-- #endregion -->

```{python slideshow={'slide_type': 'fragment'}}
try:
    2 / 0
except:
    print('Uff!')
```

<!-- #region {"slideshow": {"slide_type": "subslide"}} -->
**Tak zdefiniowane przechwytywanie jest nadczułe, gdyż może przechwycić każdy wyjątek!** Nigdy w kodzie produkcyjnym nie powinniśmy zostawiać tego typu bloków.**Zakres bloku `try` powinien być ograniczony do niezbędnego minimum**, żeby spodziewane wyjątki były łatwe do zdefiniowania, a obsługująca je struktura prosta i jednoznaczna.

W celu określenia jaki błąd chcemy przechwycić po wyrażeniu `except` podajemy nazwę wyjątku.
<!-- #endregion -->

```{python slideshow={'slide_type': 'fragment'}}
try:
    2 / 0
except ZeroDivisionError:
    print('Uff!')
```

```{python slideshow={'slide_type': 'fragment'}}
try:
    2 / unknown_variable
except ZeroDivisionError:
    print('Uff!')
```

<!-- #region {"slideshow": {"slide_type": "subslide"}} -->
W celu przechwycenia więcej niż jednego wyjątku (ale nie wszystkich) można:
* po wyrażeniu `except` podać wyjątki w tupli - wówczas wszystkie wyjątki zostaną obsłużone w ten sam sposób,
* podać więcej niż jedno wyrażenie `except` - wówczas struktura zachowa się podobnie do wyrażenia `if-elif-else`, w którym wyjątki sprawdzane będą w kolejności podania.
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
Podobieństwo jest tym większe, że możliwe jest dodanie bloku `else` wykonywanego tylko w przypadku, gdy żaden z wyjątków nie zostanie podniesiony.
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
Ostatnim wyrażeniem możliwym do zdefiniowania jest `finally`, wykonywane **zawsze** (niezależnie od podniesionego wyjątku lub jego braku) po bloku `try`.
<!-- #endregion -->

```{python slideshow={'slide_type': 'subslide'}}
def division(a, b):
    try:
        c = a / b
    except (ZeroDivisionError, TypeError):
        c = None
    else:
        print("Wynik dzielenia")
    finally:
        print(f"c: {c}")

division(4,2)
print('-' * 15)
division(4,0)
```

<!-- #region {"slideshow": {"slide_type": "subslide"}} -->
# Podnoszenie wyjątków
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
Przechwytywanie wyjątków nie zawsze musi się kończyć jego obłużeniem, czasami przydatne byłoby dodanie kodu uzupełniającego podniesiony wyjątek (np. logowanie danych o kontekście wystąpienia danego wyjątku). W celu wykonania jakiejś operacji po przechwyceniu wyjątku stosujemy następującą składnię:
<!-- #endregion -->

```{python slideshow={'slide_type': 'fragment'}}
try:
    2 / 0
except ZeroDivisionError as exc:
    print('Nieładnie')
    raise exc
```

<!-- #region {"slideshow": {"slide_type": "subslide"}} -->
# Tworzenie wyjątków
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
W niektórych przypadkach lepiej zdefiniować własny wyjątek, np. w celu rozróżnienia błedu wynikającego ze złego użycia zdefiniowanej klasy lub złych danych wejściowych, od błędu logicznego - wystąpienia sytuacji nie przewidzianej przez programistę.
<!-- #endregion -->

<!-- #region {"slideshow": {"slide_type": "fragment"}} -->
Wyjątki definiuje się jako klasę, dziediczącą po `Exception` lub którejś z klas potomnych od niej (https://docs.python.org/3/library/exceptions.html).

Struktura dziedziczenia wyjątków wbudowanych: https://docs.python.org/3/library/exceptions.html#exception-hierarchy
<!-- #endregion -->

```{python slideshow={'slide_type': 'subslide'}}
class MyException(Exception):
    pass
```

```{python slideshow={'slide_type': 'fragment'}}
class MyException(Exception):
    pass

# Błędnie przeprowadzona zmiana typu wyjątku
try:
    2 / 0
except ZeroDivisionError:
    raise MyException ('Dzielenie przez zero')
```

```{python slideshow={'slide_type': 'subslide'}}
# Wersja poprawna
try:
    2 / 0
except ZeroDivisionError as exc:
    raise MyException ('Dzielenie przez zero') from exc
```
